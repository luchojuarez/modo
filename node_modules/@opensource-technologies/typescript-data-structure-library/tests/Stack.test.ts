import { Stack } from "../src/Stack";

describe("Stack", () => {
  let stack: Stack<number>;

  beforeEach(() => {
    stack = new Stack<number>();
  });

  test("initializes an empty stack", () => {
    expect(stack.isEmpty()).toBe(true);
    expect(stack.size()).toBe(0);
  });

  test("pushes elements onto the stack", () => {
    stack.push(1);
    expect(stack.isEmpty()).toBe(false);
    expect(stack.size()).toBe(1);
  });

  test("pops elements from the stack", () => {
    stack.push(1);
    stack.push(2);
    const popped = stack.pop();
    expect(popped).toBe(2);
    expect(stack.size()).toBe(1);
  });

  test("peeks at the top element without removing it", () => {
    stack.push(1);
    stack.push(2);
    const top = stack.peek();
    expect(top).toBe(2);
    expect(stack.size()).toBe(2);
  });

  test("returns undefined when popping from an empty stack", () => {
    const popped = stack.pop();
    expect(popped).toBeUndefined();
  });

  test("returns undefined when peeking into an empty stack", () => {
    const top = stack.peek();
    expect(top).toBeUndefined();
  });

  it("should find an element in the stack", () => {
    stack.push(10);
    stack.push(20);
    stack.push(30);

    const target = 20;
    const isFound = stack.search(target);

    expect(isFound).toBe(true);
  });

  it("should not find an element not present in the stack", () => {
    stack.push(10);
    stack.push(20);
    stack.push(30);

    const target = 40;
    const isFound = stack.search(target);

    expect(isFound).toBe(false);
  });

  it("should find the target element when it is at the bottom of the stack", () => {
    stack.push(10);
    stack.push(20);
    stack.push(30);

    const target = 10;
    const isFound = stack.search(target);

    expect(isFound).toBe(true);
  });

  it("should find the target element when it is at the top of the stack", () => {
    stack.push(10);
    stack.push(20);
    stack.push(30);

    const target = 30;
    const isFound = stack.search(target);

    expect(isFound).toBe(true);
  });

  it("should preserve the original stack after searching", () => {
    stack.push(10);
    stack.push(20);
    stack.push(30);

    const originalStackSize = stack.size();
    stack.search(20);

    expect(stack.size()).toBe(originalStackSize);
  });

  it("should return false for an empty stack", () => {
    const target = 10;
    const isFound = stack.search(target);

    expect(isFound).toBe(false);
  });

  // ... existing test cases ...

  test("should sort an unsorted stack using quickSort", () => {
    stack.push(30);
    stack.push(10);
    stack.push(50);
    stack.push(20);
    stack.push(40);

    stack.quickSort();

    const sortedElements: number[] = [];
    while (!stack.isEmpty()) {
      sortedElements.push(stack.pop()!);
    }
    sortedElements.reverse();

    expect(sortedElements).toEqual([10, 20, 30, 40, 50]);
  });

  test("should handle an already sorted stack using quickSort", () => {
    stack.push(10);
    stack.push(20);
    stack.push(30);

    stack.quickSort();

    const sortedElements: number[] = [];
    while (!stack.isEmpty()) {
      sortedElements.push(stack.pop()!);
    }
    sortedElements.reverse();

    expect(sortedElements).toEqual([10, 20, 30]);
  });

  test("should handle a reverse sorted stack using quickSort", () => {
    stack.push(30);
    stack.push(20);
    stack.push(10);

    stack.quickSort();

    const sortedElements: number[] = [];
    while (!stack.isEmpty()) {
      sortedElements.push(stack.pop()!);
    }
    sortedElements.reverse();

    expect(sortedElements).toEqual([10, 20, 30]);
  });

  test("should handle a single element stack using quickSort", () => {
    stack.push(42);

    stack.quickSort();

    const sortedElements: number[] = [];
    while (!stack.isEmpty()) {
      sortedElements.push(stack.pop()!);
    }
    sortedElements.reverse();

    expect(sortedElements).toEqual([42]);
  });

  test("should handle an empty stack using quickSort", () => {
    stack.quickSort();

    const sortedElements: number[] = [];
    while (!stack.isEmpty()) {
      sortedElements.push(stack.pop()!);
    }

    expect(sortedElements).toEqual([]);
  });

  test("should sort a stack with duplicate elements using quickSort", () => {
    stack.push(30);
    stack.push(20);
    stack.push(20);
    stack.push(10);

    stack.quickSort();

    const sortedElements: number[] = [];
    while (!stack.isEmpty()) {
      sortedElements.push(stack.pop()!);
    }
    sortedElements.reverse();

    expect(sortedElements).toEqual([10, 20, 20, 30]);
  });

  test("should get the minimum element in the stack", () => {
    stack.push(30);
    stack.push(10);
    stack.push(50);
    stack.push(20);
    stack.push(40);

    const min = stack.getMin();
    expect(min).toBe(10);
  });

  test("should get the maximum element in the stack", () => {
    stack.push(30);
    stack.push(10);
    stack.push(50);
    stack.push(20);
    stack.push(40);

    const max = stack.getMax();
    expect(max).toBe(50);
  });

  test("should clone the stack", () => {
    stack.push(10);
    stack.push(20);
    stack.push(30);

    const clonedStack = stack.clone();
    expect(clonedStack.toArray()).toEqual([10, 20, 30]);
    expect(clonedStack).not.toBe(stack); // Ensure it's a different instance
  });

  test("should sort the stack using mergeSort", () => {
    stack.push(30);
    stack.push(10);
    stack.push(50);
    stack.push(20);
    stack.push(40);

    stack.mergeSort();

    const sortedElements: number[] = [];
    while (!stack.isEmpty()) {
      sortedElements.push(stack.pop()!);
    }

    expect(sortedElements).toEqual([10, 20, 30, 40, 50]);
  });

  test("should convert the stack to an array", () => {
    stack.push(10);
    stack.push(20);
    stack.push(30);

    const array = stack.toArray();
    expect(array).toEqual([10, 20, 30]);
  });

  test("should clear the stack", () => {
    stack.push(10);
    stack.push(20);
    stack.push(30);

    stack.clear();
    expect(stack.isEmpty()).toBe(true);
    expect(stack.size()).toBe(0);
  });
});
