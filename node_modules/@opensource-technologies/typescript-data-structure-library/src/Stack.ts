export class Stack<T> {
  private items: T[] = [];

  // Push an item onto the stack
  public push(item: T): void {
    this.items.push(item);
  }

  // Pop an item off the stack
  public pop(): T | undefined {
    return this.items.pop();
  }

  // Peek at the top item without removing it
  public peek(): T | undefined {
    return this.items[this.items.length - 1];
  }

  // Check if the stack is empty
  public isEmpty(): boolean {
    return this.items.length === 0;
  }

  // Get the size of the stack
  public size(): number {
    return this.items.length;
  }

  // Search for an element in the stack
  public search(target: T): boolean {
    return this.items.includes(target);
  }

  // Quick Sort function to sort the stack
  quickSort(): void {
    if (this.size() <= 1) return;

    const itemsArray = this.toArray();
    const sortedArray = this.quickSortHelper(itemsArray);

    this.clear();
    sortedArray.forEach(item => this.push(item));
  }

  private quickSortHelper(array: T[]): T[] {
    if (array.length <= 1) return array;

    const pivot = array[array.length - 1];
    const left = array.filter((item, index) => item < pivot && index !== array.length - 1);
    const right = array.filter((item, index) => item >= pivot && index !== array.length - 1);

    return [...this.quickSortHelper(left), pivot, ...this.quickSortHelper(right)];
  }

  // Ensure only one mergeSort method exists
  public mergeSort(): void {
    if (this.size() <= 1) return;

    const merge = (left: T[], right: T[]): T[] => {
      const result: T[] = [];
      while (left.length && right.length) {
        if (left[0] < right[0]) {
          result.push(left.shift()!);
        } else {
          result.push(right.shift()!);
        }
      }
      return result.concat(left, right);
    };

    const mergeSortHelper = (array: T[]): T[] => {
      if (array.length <= 1) return array;
      const mid = Math.floor(array.length / 2);
      const left = array.slice(0, mid);
      const right = array.slice(mid);
      return merge(mergeSortHelper(left), mergeSortHelper(right));
    };

    this.items = mergeSortHelper(this.items);

    // Reverse the sorted array to maintain stack order
    this.items.reverse();
  }

  // Get the minimum element in the stack
  public getMin(): T | undefined {
    if (this.isEmpty()) return undefined;
    return this.items.reduce((min, item) => (item < min ? item : min), this.items[0]);
  }

  // Get the maximum element in the stack
  public getMax(): T | undefined {
    if (this.isEmpty()) return undefined;
    return this.items.reduce((max, item) => (item > max ? item : max), this.items[0]);
  }

  // Clone the stack
  public clone(): Stack<T> {
    const newStack = new Stack<T>();
    newStack.items = [...this.items];
    return newStack;
  }

  // Convert the stack to an array
  public toArray(): T[] {
    return [...this.items];
  }

  // Clear the stack
  public clear(): void {
    this.items = [];
  }
}
