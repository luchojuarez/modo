"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryTree = exports.BinaryTreeNode = void 0;
class BinaryTreeNode {
    constructor(value) {
        this.left = null;
        this.right = null;
        this.value = value;
    }
}
exports.BinaryTreeNode = BinaryTreeNode;
class BinaryTree {
    constructor() {
        this.root = null;
    }
    // Insertion method for adding a node
    insert(value) {
        const newNode = new BinaryTreeNode(value);
        if (this.root === null) {
            this.root = newNode;
        }
        else {
            this.insertNode(this.root, newNode);
        }
    }
    insertNode(node, newNode) {
        if (newNode.value < node.value) {
            if (!node.left) {
                node.left = newNode;
            }
            else {
                this.insertNode(node.left, newNode);
            }
        }
        else {
            if (!node.right) {
                node.right = newNode;
            }
            else {
                this.insertNode(node.right, newNode);
            }
        }
    }
    // Searching method for finding a node
    search(value) {
        return this.searchNode(this.root, value) !== null;
    }
    searchNode(node, value) {
        if (!node) {
            return null;
        }
        if (value === node.value) {
            return node;
        }
        else if (value < node.value) {
            return this.searchNode(node.left, value);
        }
        else {
            return this.searchNode(node.right, value);
        }
    }
    // Deletion method for removing a node
    delete(value) {
        this.root = this.deleteNode(this.root, value);
    }
    deleteNode(node, value) {
        if (!node)
            return null;
        if (value < node.value) {
            node.left = this.deleteNode(node.left, value);
        }
        else if (value > node.value) {
            node.right = this.deleteNode(node.right, value);
        }
        else {
            // Node with only one child or no child
            if (!node.left)
                return node.right;
            if (!node.right)
                return node.left;
            // Node with two children
            const newVal = this.findMin(node.right);
            if (newVal)
                node.value = newVal;
            node.right = this.deleteNode(node.right, node.value);
        }
        return node;
    }
    // In-Order Traversal
    inOrderTraversal(node = this.root, result = []) {
        if (node) {
            this.inOrderTraversal(node.left, result);
            result.push(node.value);
            this.inOrderTraversal(node.right, result);
        }
        return result;
    }
    // Pre-Order Traversal
    preOrderTraversal(node = this.root, result = []) {
        if (node) {
            result.push(node.value);
            this.preOrderTraversal(node.left, result);
            this.preOrderTraversal(node.right, result);
        }
        return result;
    }
    // Post-Order Traversal
    postOrderTraversal(node = this.root, result = []) {
        if (node) {
            this.postOrderTraversal(node.left, result);
            this.postOrderTraversal(node.right, result);
            result.push(node.value);
        }
        return result;
    }
    // Level-Order Traversal (Breadth-First)
    levelOrderTraversal() {
        const result = [];
        if (!this.root)
            return result;
        const queue = [this.root];
        while (queue.length > 0) {
            const node = queue.shift();
            if (node) {
                result.push(node.value);
                if (node.left)
                    queue.push(node.left);
                if (node.right)
                    queue.push(node.right);
            }
        }
        return result;
    }
    // Find Minimum
    findMin(node = this.root) {
        if (!node)
            return null;
        while (node.left) {
            node = node.left;
        }
        return node.value;
    }
    // Find Maximum
    findMax(node = this.root) {
        if (!node)
            return null;
        while (node.right) {
            node = node.right;
        }
        return node.value;
    }
    // Height of the Tree
    getHeight(node = this.root) {
        if (!node)
            return 0;
        const leftHeight = this.getHeight(node.left);
        const rightHeight = this.getHeight(node.right);
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
exports.BinaryTree = BinaryTree;
