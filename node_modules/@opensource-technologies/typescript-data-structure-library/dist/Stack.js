"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stack = void 0;
class Stack {
    constructor() {
        this.items = [];
    }
    // Push an item onto the stack
    push(item) {
        this.items.push(item);
    }
    // Pop an item off the stack
    pop() {
        return this.items.pop();
    }
    // Peek at the top item without removing it
    peek() {
        return this.items[this.items.length - 1];
    }
    // Check if the stack is empty
    isEmpty() {
        return this.items.length === 0;
    }
    // Get the size of the stack
    size() {
        return this.items.length;
    }
    // Search for an element in the stack
    search(target) {
        return this.items.includes(target);
    }
    // Quick Sort function to sort the stack
    quickSort() {
        if (this.size() <= 1)
            return;
        const itemsArray = this.toArray();
        const sortedArray = this.quickSortHelper(itemsArray);
        this.clear();
        sortedArray.forEach(item => this.push(item));
    }
    quickSortHelper(array) {
        if (array.length <= 1)
            return array;
        const pivot = array[array.length - 1];
        const left = array.filter((item, index) => item < pivot && index !== array.length - 1);
        const right = array.filter((item, index) => item >= pivot && index !== array.length - 1);
        return [...this.quickSortHelper(left), pivot, ...this.quickSortHelper(right)];
    }
    // Ensure only one mergeSort method exists
    mergeSort() {
        if (this.size() <= 1)
            return;
        const merge = (left, right) => {
            const result = [];
            while (left.length && right.length) {
                if (left[0] < right[0]) {
                    result.push(left.shift());
                }
                else {
                    result.push(right.shift());
                }
            }
            return result.concat(left, right);
        };
        const mergeSortHelper = (array) => {
            if (array.length <= 1)
                return array;
            const mid = Math.floor(array.length / 2);
            const left = array.slice(0, mid);
            const right = array.slice(mid);
            return merge(mergeSortHelper(left), mergeSortHelper(right));
        };
        this.items = mergeSortHelper(this.items);
        // Reverse the sorted array to maintain stack order
        this.items.reverse();
    }
    // Get the minimum element in the stack
    getMin() {
        if (this.isEmpty())
            return undefined;
        return this.items.reduce((min, item) => (item < min ? item : min), this.items[0]);
    }
    // Get the maximum element in the stack
    getMax() {
        if (this.isEmpty())
            return undefined;
        return this.items.reduce((max, item) => (item > max ? item : max), this.items[0]);
    }
    // Clone the stack
    clone() {
        const newStack = new Stack();
        newStack.items = [...this.items];
        return newStack;
    }
    // Convert the stack to an array
    toArray() {
        return [...this.items];
    }
    // Clear the stack
    clear() {
        this.items = [];
    }
}
exports.Stack = Stack;
